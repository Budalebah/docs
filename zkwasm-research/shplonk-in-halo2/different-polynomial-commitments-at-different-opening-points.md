# Different Polynomial Commitments at different opening points

We have already established that we can group together the openings of any homomorphic polynomial commitment scheme when they correspond to **the same point**. Now, we are extending this capability to include **different points** as well.

Let <img src="../../.gitbook/assets/image (20).png" alt="" data-size="line"> be a set of commitments and <img src="../../.gitbook/assets/image (13).png" alt="" data-size="line"> a set of points in 𝔽𝑝 . To open the commitments on the Z𝑖 :

1. A prover sends the individual proofs <img src="../../.gitbook/assets/image (39).png" alt="" data-size="line"> as well as the evaluations <img src="../../.gitbook/assets/image (49).png" alt="" data-size="line"> .
2.  A verifier chooses random numbers <img src="../../.gitbook/assets/image (61).png" alt="" data-size="line"> and computes <img src="../../.gitbook/assets/image (30).png" alt="" data-size="line"> and checks that: &#x20;

    <figure><img src="../../.gitbook/assets/image (51).png" alt="" width="375"><figcaption></figcaption></figure>

This method works well if there are few points, because calculating K’ is **costly** (usually 𝔾 is a subgroup of the 𝔽𝑝 points on an elliptic curve over 𝔽𝑝 , and calculating 𝐾’ needs a multi exponentiation on this group).&#x20;

Here below is the description of the batching algorithm in Plonk:

<table><thead><tr><th width="280"></th><th></th></tr></thead><tbody><tr><td><ol><li>Circuit Encoding:</li></ol></td><td><ul><li><p>For each circuit instance 𝑖: </p><ul><li>Encode the circuit instance as an arithmetic circuit with variables <img src="../../.gitbook/assets/image (16).png" alt="" data-size="line">representing the wires of the circuit instance.</li></ul></li></ul></td></tr><tr><td><ol start="2"><li>Polynomial Commitments:</li></ol></td><td><ul><li><p>For each circuit instance i:</p><ul><li>Create polynomial commitments for the wire polynomials of the circuit instance.</li><li>Let <img src="../../.gitbook/assets/image (72).png" alt="" data-size="line"> represent the commitment to wire polynomial <img src="../../.gitbook/assets/image (4).png" alt="" data-size="line"> of circuit instance 𝑖.</li></ul></li></ul></td></tr><tr><td><ol start="3"><li>Constraint System:</li></ol></td><td><ul><li><p>For each circuit instance 𝑖:</p><ul><li>Define a set of constraints that enforce the correctness of the circuit instance.</li><li>Each constraint represents a gate in the circuit instance and relates the input and output wires. </li><li>Express the constraints as polynomial equations for circuit instance 𝑖.</li><li>Let <img src="../../.gitbook/assets/image (53).png" alt="" data-size="line"> represent the constraint equation 𝑘 for circuit instance 𝑖.</li></ul></li></ul></td></tr><tr><td><ol start="4"><li>Low-Degree Extension:</li></ol></td><td><ul><li><p>For each circuit instance 𝑖:</p><ul><li>Extend the wire polynomials of circuit instance 𝑖 to a higher degree using low-degree extension techniques.</li><li>Let 𝑤{𝑖,𝑗} (𝑥) represent the extended wire polynomial 𝑤{𝑖,𝑗} of circuit instance 𝑖.</li></ul></li></ul></td></tr><tr><td><ol start="5"><li>Evaluation of Constraints:</li></ol></td><td><ul><li><p>For each circuit instance 𝑖:</p><ul><li>Evaluate the constraint polynomials of circuit instance 𝑖 at specific points using the extended wire polynomials.</li><li>Let <img src="../../.gitbook/assets/image (69).png" alt="" data-size="original"> represent the evaluation of constraint 𝑘 for circuit instance 𝑖.</li></ul></li></ul></td></tr><tr><td><ol start="6"><li>Random Polynomial Construction:</li></ol></td><td><ul><li><p>For each circuit instance 𝑖:</p><ul><li>Construct a random polynomial that satisfies the constraints of circuit instance 𝑖.</li><li>Let 𝑟𝑖 (𝑥) represent the random polynomial for circuit instance 𝑖.</li></ul></li></ul></td></tr><tr><td><ol start="7"><li>Batching:</li></ol></td><td><ul><li>Aggregate the wire polynomials, constraint evaluations, and random polynomials of all circuit instances into a single set of polynomials.</li></ul><ul><li>Concatenate the wire polynomials, constraint evaluations, and random polynomials of all circuit instances into larger polynomials.</li><li><p></p><div><figure><img src="../../.gitbook/assets/image (50).png" alt=""><figcaption></figcaption></figure></div></li></ul></td></tr><tr><td><ol start="8"><li>Opening and Proof Generation:</li></ol></td><td><ul><li>Open the commitments to the aggregated wire polynomials and random polynomials.</li><li>Verify that the openings are consistent with the computed evaluations for the aggregated polynomials.</li><li><p>Generate a proof of knowledge that the commitments were constructed honestly for the aggregated polynomials.</p><ul><li>Opening of Commitments: 𝑂𝑝𝑒𝑛(𝐶𝑜𝑚𝑚𝑖𝑡(𝑤{𝑖,𝑗} ))</li><li> Proof of Knowledge: 𝑃𝑟𝑜𝑜𝑓(. . . )</li></ul></li></ul></td></tr><tr><td><ol start="9"><li>Verification:</li></ol></td><td><ul><li>Verify the proof of knowledge and the consistency of the openings for the aggregated polynomials.</li><li>Check that the constraint evaluations and the constraint equations match for the aggregated polynomials.</li><li>Validate the correctness of all circuit instances and the integrity of the aggregated proof.</li></ul></td></tr></tbody></table>

Note that the above steps provide an algebraic representation of the batching algorithm in PLONK. It assumes that the commitments, constraint evaluations, and random polynomials can be aggregated and concatenated appropriately.&#x20;

The exact implementation details may vary based on the specific polynomial commitment scheme and cryptographic operations used in PLONK. By batch processing multiple circuit instances, the batching algorithm in PLONK reduces the number of commitment openings and proof generation steps required, resulting in improved efficiency and scalability.&#x20;

It allows for generating a single proof that can simultaneously validate the correctness of multiple circuit instances. Since PLONK relies on general polynomial commitment schemes (here only the Kate commitment scheme was presented), it is quite flexible and can be used for proof carrying data constructions such as Halo2 proving framework.
